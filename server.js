const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst fs = require('fs');\nconst path = require('path');\nconst QRCode = require('qrcode');\nconst { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\nconst pino = require('pino');\nconst multer = require('multer');\nconst cors = require('cors');\nconst mime = require('mime-types');\nconst fsExtra = require('fs-extra');\nconst cron = require('node-cron');\n\n// Initialize Express app\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server, {\n    cors: {\n        origin: \"*\",\n        methods: [\"GET\", \"POST\"]\n    }\n});\n\n// Middleware\napp.use(cors());\napp.use(express.json({ limit: '50mb' }));\napp.use(express.urlencoded({ extended: true, limit: '50mb' }));\n\n// Log all requests for debugging\napp.use((req, res, next) => {\n    console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);\n    next();\n});\n\n// Serve static files from public directory with proper MIME types\napp.use('/public', express.static(path.join(__dirname, 'public'), {\n    setHeaders: (res, path) => {\n        if (path.endsWith('.css')) {\n            res.setHeader('Content-Type', 'text/css');\n        } else if (path.endsWith('.js')) {\n            res.setHeader('Content-Type', 'application/javascript');\n        }\n    }\n}));\n\napp.use('/uploads', express.static(path.join(__dirname, 'uploads')));\n\n// Test route\napp.get('/test', (req, res) => {\n    console.log('Test route accessed');\n    res.sendFile(path.join(__dirname, 'test.html'));\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n    res.json({ \n        status: 'OK', \n        timestamp: new Date().toISOString(),\n        uptime: process.uptime(),\n        connected: isConnected,\n        version: '3.0.0'\n    });\n});\n\n// Debug route to check file existence\napp.get('/debug', (req, res) => {\n    const indexPath = path.join(__dirname, 'index.html');\n    const testPath = path.join(__dirname, 'test.html');\n    const publicPath = path.join(__dirname, 'public');\n    \n    res.json({\n        indexExists: fs.existsSync(indexPath),\n        testExists: fs.existsSync(testPath),\n        publicExists: fs.existsSync(publicPath),\n        indexPath: indexPath,\n        testPath: testPath,\n        publicPath: publicPath,\n        currentDir: __dirname,\n        files: fs.readdirSync(__dirname)\n    });\n});\n\n// Serve main HTML file with better error handling\napp.get('/', (req, res) => {\n    const indexPath = path.join(__dirname, 'index.html');\n    console.log('Root route accessed, serving:', indexPath);\n    \n    if (fs.existsSync(indexPath)) {\n        console.log('index.html exists, sending file');\n        res.sendFile(indexPath, (err) => {\n            if (err) {\n                console.error('Error sending index.html:', err);\n                res.status(500).send('Error loading page');\n            } else {\n                console.log('index.html sent successfully');\n            }\n        });\n    } else {\n        console.error('index.html not found at:', indexPath);\n        res.status(404).send(`File not found: ${indexPath}`);\n    }\n});\n\n// Create necessary directories\nconst createDirectories = () => {\n    const dirs = ['./auth_info_baileys', './data', './uploads'];\n    dirs.forEach(dir => {\n        if (!fs.existsSync(dir)) {\n            fs.mkdirSync(dir, { recursive: true });\n        }\n    });\n};\n\n// Data file paths\nconst DATA_FILES = {\n    templates: './data/templates.json',\n    contactGroups: './data/contact_groups.json',\n    messages: './data/messages.json'\n};\n\n// Initialize data files\nconst initializeDataFiles = () => {\n    Object.values(DATA_FILES).forEach(file => {\n        if (!fs.existsSync(file)) {\n            fs.writeFileSync(file, JSON.stringify([]));\n        }\n    });\n};\n\n// Utility functions for data management\nconst loadData = (filename) => {\n    try {\n        const data = fs.readFileSync(filename, 'utf8');\n        return JSON.parse(data);\n    } catch (error) {\n        console.error(`Error loading ${filename}:`, error);\n        return [];\n    }\n};\n\nconst saveData = (filename, data) => {\n    try {\n        fs.writeFileSync(filename, JSON.stringify(data, null, 2));\n        return true;\n    } catch (error) {\n        console.error(`Error saving ${filename}:`, error);\n        return false;\n    }\n};\n\n// WhatsApp variables\nlet sock;\nlet qrCodeData = null;\nlet isConnected = false;\nlet contacts = new Map();\nlet groups = new Map();\n\n// Store message\nconst storeMessage = (messageData) => {\n    try {\n        const messages = loadData(DATA_FILES.messages);\n        messages.push(messageData);\n        \n        // Keep only last 1000 messages\n        if (messages.length > 1000) {\n            messages.splice(0, messages.length - 1000);\n        }\n        \n        saveData(DATA_FILES.messages, messages);\n    } catch (error) {\n        console.error('Error storing message:', error);\n    }\n};\n\n// WhatsApp connection function\nconst connectToWhatsApp = async () => {\n    try {\n        const { state, saveCreds } = await useMultiFileAuthState('./auth_info_baileys');\n        \n        sock = makeWASocket({\n            auth: state,\n            printQRInTerminal: false,\n            logger: pino({ level: 'silent' }),\n            browser: ['WhatsApp Web Client', 'Chrome', '4.0.0']\n        });\n\n        sock.ev.on('connection.update', async (update) => {\n            const { connection, lastDisconnect, qr } = update;\n            \n            if (qr) {\n                try {\n                    qrCodeData = await QRCode.toDataURL(qr);\n                    console.log('📱 QR Code generated successfully');\n                    console.log(`📱 [${new Date().toLocaleTimeString()}] qr_code: {\"qr\":\"${qrCodeData.substring(0, 100)}...\"}`);\n                    io.emit('qr', qrCodeData);\n                } catch (error) {\n                    console.error('Error generating QR code:', error);\n                }\n            }\n            \n            if (connection === 'close') {\n                isConnected = false;\n                const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;\n                console.log('Connection closed due to ', lastDisconnect?.error, ', reconnecting ', shouldReconnect);\n                \n                io.emit('disconnected');\n                \n                if (shouldReconnect) {\n                    setTimeout(() => connectToWhatsApp(), 3000);\n                }\n            } else if (connection === 'open') {\n                isConnected = true;\n                qrCodeData = null;\n                console.log('WhatsApp connected successfully');\n                \n                io.emit('ready');\n                \n                // Load contacts and groups\n                setTimeout(async () => {\n                    await loadContactsAndGroups();\n                }, 2000);\n            }\n        });\n\n        sock.ev.on('creds.update', saveCreds);\n        \n        sock.ev.on('messages.upsert', async ({ messages, type }) => {\n            if (type === 'notify') {\n                for (const message of messages) {\n                    if (message.message) {\n                        const messageData = {\n                            id: message.key.id,\n                            from: message.key.remoteJid,\n                            to: sock.user?.id || '',\n                            message: message.message.conversation || \n                                    message.message.extendedTextMessage?.text || \n                                    'Media message',\n                            timestamp: Date.now(),\n                            type: 'received',\n                            status: 'delivered'\n                        };\n                        \n                        storeMessage(messageData);\n                        io.emit('message', messageData);\n                    }\n                }\n            }\n        });\n        \n    } catch (error) {\n        console.error('Error connecting to WhatsApp:', error);\n        setTimeout(() => connectToWhatsApp(), 5000);\n    }\n};\n\n// Load contacts and groups\nconst loadContactsAndGroups = async () => {\n    try {\n        if (sock && isConnected) {\n            // Get contacts\n            const contactsList = Object.entries(sock.authState.creds.contacts || {});\n            contacts.clear();\n            \n            contactsList.forEach(([jid, contact]) => {\n                if (jid.includes('@s.whatsapp.net')) {\n                    contacts.set(jid, {\n                        id: jid,\n                        name: contact.name || contact.notify || jid.split('@')[0],\n                        number: jid.split('@')[0]\n                    });\n                }\n            });\n            \n            // Get groups\n            const groupsList = await sock.groupFetchAllParticipating();\n            groups.clear();\n            \n            Object.values(groupsList).forEach(group => {\n                groups.set(group.id, {\n                    id: group.id,\n                    subject: group.subject,\n                    participants: group.participants.map(p => p.id)\n                });\n            });\n            \n            console.log(`Loaded ${contacts.size} contacts and ${groups.size} groups`);\n            \n            // Send to clients\n            io.emit('contacts', Array.from(contacts.values()));\n            io.emit('chats', Array.from(groups.values()));\n        }\n    } catch (error) {\n        console.error('Error loading contacts and groups:', error);\n    }\n};\n\n// API Routes\n\n// Status endpoint\napp.get('/api/status', (req, res) => {\n    res.json({\n        connected: isConnected,\n        qrCode: qrCodeData,\n        contactsCount: contacts.size,\n        groupsCount: groups.size\n    });\n});\n\n// Socket.io connection handling\nio.on('connection', (socket) => {\n    console.log('Client connected:', socket.id);\n    \n    // Send current status\n    if (isConnected) {\n        socket.emit('ready');\n        socket.emit('contacts', Array.from(contacts.values()));\n        socket.emit('chats', Array.from(groups.values()));\n    } else if (qrCodeData) {\n        socket.emit('qr', qrCodeData);\n    }\n    \n    // Handle send message\n    socket.on('sendMessage', async (data, callback) => {\n        try {\n            if (!sock || !isConnected) {\n                callback({ success: false, error: 'WhatsApp not connected' });\n                return;\n            }\n\n            const { number, message } = data;\n            const result = await sock.sendMessage(number, { text: message });\n            \n            callback({ success: true, messageId: result.key.id });\n        } catch (error) {\n            console.error('Error sending message:', error);\n            callback({ success: false, error: error.message });\n        }\n    });\n    \n    socket.on('disconnect', () => {\n        console.log('Client disconnected:', socket.id);\n    });\n});\n\n// Start server\nconst PORT = process.env.PORT || 3000;\n\nserver.listen(PORT, async () => {\n    console.log(`🚀 Server running on port ${PORT}`);\n    console.log(`📱 Access the app at: http://localhost:${PORT}`);\n    console.log(`🌐 Environment: ${process.env.NODE_ENV || 'development'}`);\n    console.log(`📊 Health check: http://localhost:${PORT}/health`);\n    \n    // Initialize directories and data files\n    console.log('✅ Data directories created successfully');\n    createDirectories();\n    initializeDataFiles();\n    \n    // Initialize WhatsApp connection\n    console.log('🔄 [' + new Date().toLocaleTimeString() + '] Attempting to initialize WhatsApp client (attempt 1/3)');\n    await connectToWhatsApp();\n});\n\nmodule.exports = { app, server, io };"